package com.cloudberry.cloudberry.db.common.service;

import com.cloudberry.cloudberry.db.common.data.ParsedLogs;
import com.cloudberry.cloudberry.db.influx.InfluxDefaults;
import com.cloudberry.cloudberry.db.mongo.data.metadata.ExperimentConfiguration;
import com.cloudberry.cloudberry.db.mongo.data.metadata.ExperimentEvaluation;
import com.cloudberry.cloudberry.util.XmlUtils;
import com.influxdb.client.write.Point;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.bson.types.ObjectId;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static java.lang.Long.parseLong;

@Slf4j
@Service
@RequiredArgsConstructor
public class LogsParserImpl implements LogsParser<ParsedLogs> {
    @Value("${influx.buckets.default-logs}")
    private String defaultLogsBucketName;
    private static final String MEASUREMENT_PREFIX = "measurement_";
    private final Map<String, String> keys = Map.of("[WH]", "[W]", "[SH]", "[S]", "[BH]", "[B]");
    // todo ^ above fields can come from e.g. rest parameter

    @Override
    public List<ParsedLogs> parseMeasurements(String rawLogs) {
        var parsedLogs = parseLogs(rawLogs);
        var evaluationId = parsedLogs.getExperimentEvaluation().getId();
        parsedLogs.getPoints()
                .forEach(point -> point.addTag(InfluxDefaults.CommonTags.EVALUATION_ID, evaluationId.toHexString()));
        return List.of(parsedLogs);
    }

    private ParsedLogs parseLogs(String rawLogs) {
        var now = Instant.now();
        var parameters = new HashMap<String, String[]>();
        List<Point> evaluationLogs = new LinkedList<>();

        // todo find based on map & save Experiment with name to db
        var experimentId = new ObjectId();

        // todo make its ID generated by db, without this its null and evaluation doesnt't have it
        var experimentConfiguration = new ExperimentConfiguration(
                new ObjectId(),
                now,
                experimentId,
                Collections.emptyMap()
        );

        var experimentEvaluation = new ExperimentEvaluation(
                new ObjectId(),
                experimentConfiguration.getId(),
                now
        );

        String[] logs = rawLogs.split("\n");
        for (int i = 0; i < logs.length; i++) {
            String rawLog = logs[i];
            String[] log = rawLog.trim().split(";");

            String logPrefix = log[0];
            if (keys.containsKey(logPrefix)) {
                saveParametersOrder(parameters, logPrefix, log);
            } else if (keys.containsValue(logPrefix)) {
                evaluationLogs.add(getMeasurementPoint(parameters, logPrefix, log));
            } else if (rawLog.startsWith("<")) {
                List<String> xmlLogs = new LinkedList<>();
                String tagName = XmlUtils.getTagName(rawLog);
                String closingTag = null;
                while (!tagName.equals(closingTag)) {
                    i++;
                    rawLog = logs[i];
                    xmlLogs.add(rawLog);
                    closingTag = XmlUtils.getClosingTagName(rawLog);
                }
                xmlLogs.remove(rawLog); //remove closing tag from list
                var xmlMap = getXmlMap(xmlLogs);
                experimentConfiguration.setParameters(xmlMap);
                experimentConfiguration.setConfigurationFileName(String.valueOf(xmlMap.get("file")));
            } else {
                LogsParserImpl.log.warn("Header {} not parsed", log[0]);
            }
        }

        return new ParsedLogs(defaultLogsBucketName, evaluationLogs, experimentConfiguration, experimentEvaluation);
    }

    private Map<String, Object> getXmlMap(List<String> xmlLogs) {
        return xmlLogs.stream()
                .map(xmlLog -> xmlLog.split("=", 2))
                .collect(
                        Collectors.toMap(
                                log -> log[0].trim(),
                                log -> parseValue(log[1].trim())
                        )
                );
    }

    private Point getMeasurementPoint(Map<String, String[]> parameters, String logType, String[] log) {
        Point point = Point.measurement(MEASUREMENT_PREFIX + logType)
                .addFields(getMapFromArrays(parameters.get(logType), log));

        if (parameters.get(logType)[1].equalsIgnoreCase("time")) {
            long time = parseLong(log[1]);
            point.time(time, InfluxDefaults.WRITE_PRECISION);
        }

        return point;
    }

    /**
     * @param log examples:
     *            [WH];TIME;WORKPLACE_ID;POPULATION_SIZE;AVERAGE_FITNESS;STEP_NUMBER;ENERGY_SUM
     *            [SH];TIME;BEST_SOLUTION_SO_FAR;FITNESS_EVALUATIONS
     */
    private void saveParametersOrder(Map<String, String[]> parameters, String logType, String[] log) {
        String logKey = keys.get(logType);
        parameters.compute(logKey, (s, fieldNames) -> {
            if (fieldNames == null) {
                return log;
            }
            throw new IllegalArgumentException(String.format("Log with prefix [%s] already specified.", logType));
        });
    }

    private Map<String, Object> getMapFromArrays(String[] keys, String[] values) {
        return IntStream.range(0, keys.length).boxed()
                .collect(Collectors.toMap(i -> keys[i], i -> parseValue(values[i])));
    }

    private Object parseValue(String value) {
        try {
            return Double.parseDouble(value);
        } catch (NumberFormatException e) {
            return value;
        }
    }
}
